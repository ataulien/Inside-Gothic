{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Inside-Gothic In this Document, I am going to discuss the architecture of the games Gothic I & II by Piranha Bytes , as figured out by developing REGoth and REGoth-bs . Both games are built upon the zEngine or ZenGin , originally developed by a group of students called Mad Scientists . If you want to know more about the development of Gothic, I recommend the excellent series Gothic in a Nutshell by arhn.eu. These texts are not meant to be a strict reference, but rather a peek into the engines architecture and functionality for those interested to learn more about the inner workings of the Gothic games on a higher level. You can edit this document on Github . Note This is a work-in-progress.","title":"Home"},{"location":"#welcome-to-inside-gothic","text":"In this Document, I am going to discuss the architecture of the games Gothic I & II by Piranha Bytes , as figured out by developing REGoth and REGoth-bs . Both games are built upon the zEngine or ZenGin , originally developed by a group of students called Mad Scientists . If you want to know more about the development of Gothic, I recommend the excellent series Gothic in a Nutshell by arhn.eu. These texts are not meant to be a strict reference, but rather a peek into the engines architecture and functionality for those interested to learn more about the inner workings of the Gothic games on a higher level. You can edit this document on Github . Note This is a work-in-progress.","title":"Welcome to Inside-Gothic"},{"location":"ActionQueue/","text":"Action-Queue While in Gothic, every Vob can have an Action-Queue, they are most used by Npcs. Actually, the Action-Queue is the inner core of Npc behavior ! The Action-Queue itself is best described as a First-In-First-Out buffer with extra steps. It holds actions of the following categories: Damage Weapon Movement (Go somewhere) Attack (Single attacks) UseItem Script State Manipulate (Items/Mobs) Conversation Magic For a full list of categories and sub-types, basically everything an Npc can do in Gothic, see this document . On every frame, the action at the front of the queue is executed. The action itself can decide whether it is done after it was executed, or if it needs to be executed again next frame: If the action says it is done , it will be popped from the queue and the next action will be executed next frame. If the action is not done yet, it will stay at the front of the queue and will be executed again next frame. Example Let's assume the following sequence of actions has been pushed into an Npcs Action-Queue: Index 0 1 2 3 4 Action Goto Location Take Item Use Item (Beer) Goto Character (Player) Give Item (5x Ore) The Action at index 0 ( Goto Location ) is at the front of the queue and thus will be executed for as long as the Npc is not at the target location. On every frame, when the Goto Location action is executed, it will check whether the Npc arrived at its destination. Lets say, it did. Then, the action will be popped off the Queue and the next one takes its place. The Queue now looks like this: Index 0 1 2 3 Action Take Item Use Item (Beer) Goto Character (Player) Give Item (5x Ore) The next Action is now at the front of the queue and will be executed. For Take Item , it will block the queue until all animations have been finished and the item is in the inventory (if the Npc could pick it up, that is). After the item was picked up, the Action signals that it is done. The queue now looks like this: Index 0 1 2 Action Use Item (Beer) Goto Character (Player) Give Item (5x Ore) And so on, you get the Idea. Filling the Queue via Scripting The Action-Queue is the most important system to let the games scripts work in the way they do. Many of the Npc related script external functions actually just push an action into the queue and continue with executing the script. Most commonly used in dialogues, the AI_Output external lets a character say something. In the original scripts, a dialogue can look like this : FUNC void PC_Thief_WHEEL_Info () { AI_Output ( self , hero , \"PC_Thief_WHEEL_Info_11_01\" ); //Die Winde scheint zu klemmen. AI_Output ( self , hero , \"PC_Thief_WHEEL_Info_11_02\" ); //Lass mich mal, vielleicht kann ich da was machen! AI_StopProcessInfos ( self ); // Cancels dialogue AI_GotoWP ( self , \"LOCATION_12_14_WHEEL\" ); AI_AlignToWP ( self ); AI_PlayAni ( self , \"T_PLUNDER\" ); }; In this dialogue option, Diego tells the Hero \"Let me try\" and goes to the broken wind to turn it. All those AI_ -functions push an action into Diegos Action-Queue and are executed sequentially, one after another. Overlay Events Usually, only the event at the front of the queue is active and passed to the target object. However, events marked as \"Overlay\" will act a little bit different. If such an overlay-event is at the front of the queue, it will be passed to the target object every update cycle. Then, the next event in the queue is looked at. If that is also an overlay-event, it is passed to the object as well. This continues until the first event is encountered which is not an overlay. That will be the last event passed to the object.","title":"Action Queue"},{"location":"ActionQueue/#action-queue","text":"While in Gothic, every Vob can have an Action-Queue, they are most used by Npcs. Actually, the Action-Queue is the inner core of Npc behavior ! The Action-Queue itself is best described as a First-In-First-Out buffer with extra steps. It holds actions of the following categories: Damage Weapon Movement (Go somewhere) Attack (Single attacks) UseItem Script State Manipulate (Items/Mobs) Conversation Magic For a full list of categories and sub-types, basically everything an Npc can do in Gothic, see this document . On every frame, the action at the front of the queue is executed. The action itself can decide whether it is done after it was executed, or if it needs to be executed again next frame: If the action says it is done , it will be popped from the queue and the next action will be executed next frame. If the action is not done yet, it will stay at the front of the queue and will be executed again next frame.","title":"Action-Queue"},{"location":"ActionQueue/#example","text":"Let's assume the following sequence of actions has been pushed into an Npcs Action-Queue: Index 0 1 2 3 4 Action Goto Location Take Item Use Item (Beer) Goto Character (Player) Give Item (5x Ore) The Action at index 0 ( Goto Location ) is at the front of the queue and thus will be executed for as long as the Npc is not at the target location. On every frame, when the Goto Location action is executed, it will check whether the Npc arrived at its destination. Lets say, it did. Then, the action will be popped off the Queue and the next one takes its place. The Queue now looks like this: Index 0 1 2 3 Action Take Item Use Item (Beer) Goto Character (Player) Give Item (5x Ore) The next Action is now at the front of the queue and will be executed. For Take Item , it will block the queue until all animations have been finished and the item is in the inventory (if the Npc could pick it up, that is). After the item was picked up, the Action signals that it is done. The queue now looks like this: Index 0 1 2 Action Use Item (Beer) Goto Character (Player) Give Item (5x Ore) And so on, you get the Idea.","title":"Example"},{"location":"ActionQueue/#filling-the-queue-via-scripting","text":"The Action-Queue is the most important system to let the games scripts work in the way they do. Many of the Npc related script external functions actually just push an action into the queue and continue with executing the script. Most commonly used in dialogues, the AI_Output external lets a character say something. In the original scripts, a dialogue can look like this : FUNC void PC_Thief_WHEEL_Info () { AI_Output ( self , hero , \"PC_Thief_WHEEL_Info_11_01\" ); //Die Winde scheint zu klemmen. AI_Output ( self , hero , \"PC_Thief_WHEEL_Info_11_02\" ); //Lass mich mal, vielleicht kann ich da was machen! AI_StopProcessInfos ( self ); // Cancels dialogue AI_GotoWP ( self , \"LOCATION_12_14_WHEEL\" ); AI_AlignToWP ( self ); AI_PlayAni ( self , \"T_PLUNDER\" ); }; In this dialogue option, Diego tells the Hero \"Let me try\" and goes to the broken wind to turn it. All those AI_ -functions push an action into Diegos Action-Queue and are executed sequentially, one after another.","title":"Filling the Queue via Scripting"},{"location":"ActionQueue/#overlay-events","text":"Usually, only the event at the front of the queue is active and passed to the target object. However, events marked as \"Overlay\" will act a little bit different. If such an overlay-event is at the front of the queue, it will be passed to the target object every update cycle. Then, the next event in the queue is looked at. If that is also an overlay-event, it is passed to the object as well. This continues until the first event is encountered which is not an overlay. That will be the last event passed to the object.","title":"Overlay Events"},{"location":"DailyRoutine/","text":"Daily Routines As discussed in the NPC class overview , the Daily Routine is executed if an NPC has nothing else to do. They are defined via Daedalus-scripts. For example, this is Diegos Daily Routine after you talked to him at the start of the game ( TA meaning Tages Ablauf , just Daily Routine in German): FUNC VOID Rtn_Start_1 () { // Start End TA_Sleep ( 23 , 00 , 03 , 00 , \"OCR_HUT_1\" ); TA_SitAround ( 03 , 00 , 05 , 30 , \"OCR_HUT_Z5_SIT3\" ); TA_Sleep ( 05 , 30 , 07 , 00 , \"OCR_CAULDRON_1\" ); TA_SitAround ( 07 , 00 , 10 , 00 , \"OCR_CAULDRON_1\" ); TA_Smalltalk ( 10 , 00 , 12 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT1\" ); //mit Grim TA_SitAround ( 12 , 00 , 16 , 00 , \"OCR_CAULDRON_1\" ); TA_Smalltalk ( 16 , 00 , 18 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT3\" ); //mit Stt_322 TA_SitCampfire ( 18 , 00 , 23 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT1\" ); }; Script functions like the one above are executed once when the NPC is spawned or has changed its Daily Routine. Each of the function calls registers its activity in the Todo-list each Npc has for the specified timespan and Waypoint, which specifies the location on where that activity should be done. Internally, each of those TA_something -functions maps to only one script external, TA_Min . A complete list of all possible actions is defined here . Waypoints as rough location markers As you can see in the code snipped above, there is an interesting comment, // mit Grim : TA_Smalltalk (..., \"OCR_CAMPFIRE_A_MOVEMENT1\" ) // mit Grim This says, that Diego should to Smalltalk with the Npc Grim . However, that is just a code comment. The TA_Smalltalk activity just searches for any nearby Npc to do smalltalk with. In Grims Daily Routine, there is a similar entry, which makes them both go to the same location to meet there every day. Both of them just don't know who to expect there and meet every day by \"chance\", which is kinda funny. This also applies to states where interactive items are involved. They usually just say Go to some location and see if you can find an Amboss to work on . If that is already occupied, the Npc may do something else instead. Script States This is a complex topic, which I need to quickly go over for daily routines. However, Script States are also used for other purposes extensively. Each of the Daily-Routine actions registered for that Npc executes a Script State on that Npc when its time has come. For example, lets look at this line again: TA_Smalltalk ( 10 , 00 , 12 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT1\" ); //mit Grim On execution, this registers the Script State ZS_SMALLTALK from 10:00 to 12:00 at the location OCR_CAMPFIRE_A_MOVEMENT1 in Diegos Daily Routine. ZS_SMALLTALK is then defined here . Each Script State can have the following script functionality: An init function, called once when the state is started A loop function, called every frame while the state is active and there is nothing else to do. This function can also decide whether the state should continue. An end function, called when the state has ended. If the time goes on and a different Daily Routine action gets activated, the current state is canceled gracefully and the next state is started. Example For ZS_SMALLTALK , you can break that down in the following (as seen from the Npcs perspecitve): Begin the state: Set me to slow-walkmode. If I am not already on a Freepoint called SMALLTALK , let me go to the Waypoint registered in the Daily Routine. Then, let me go to the next unoccupied Freepoint called SMALLTALK . Face into the direction of the Freepoint. Then, when there is nothing else to do: On this particular Script-State, there is not action when the state ended. Interruptions Execution of the Script State belonging to the current Daily Routine action is interrupted by assigning any other Script State to the Npc, ie. when when taking damage or talking to the Npc, which starts ZS_TALK . Once the non-routine Script State is over and the Npc has nothing to do anymore, the Daily Routine is started again. Weird Daily Routines There are some gameplay elements you wouldn't think of as a Daily Routine, such as Following the Player Guiding the player to some location","title":"Daily Routine"},{"location":"DailyRoutine/#daily-routines","text":"As discussed in the NPC class overview , the Daily Routine is executed if an NPC has nothing else to do. They are defined via Daedalus-scripts. For example, this is Diegos Daily Routine after you talked to him at the start of the game ( TA meaning Tages Ablauf , just Daily Routine in German): FUNC VOID Rtn_Start_1 () { // Start End TA_Sleep ( 23 , 00 , 03 , 00 , \"OCR_HUT_1\" ); TA_SitAround ( 03 , 00 , 05 , 30 , \"OCR_HUT_Z5_SIT3\" ); TA_Sleep ( 05 , 30 , 07 , 00 , \"OCR_CAULDRON_1\" ); TA_SitAround ( 07 , 00 , 10 , 00 , \"OCR_CAULDRON_1\" ); TA_Smalltalk ( 10 , 00 , 12 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT1\" ); //mit Grim TA_SitAround ( 12 , 00 , 16 , 00 , \"OCR_CAULDRON_1\" ); TA_Smalltalk ( 16 , 00 , 18 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT3\" ); //mit Stt_322 TA_SitCampfire ( 18 , 00 , 23 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT1\" ); }; Script functions like the one above are executed once when the NPC is spawned or has changed its Daily Routine. Each of the function calls registers its activity in the Todo-list each Npc has for the specified timespan and Waypoint, which specifies the location on where that activity should be done. Internally, each of those TA_something -functions maps to only one script external, TA_Min . A complete list of all possible actions is defined here .","title":"Daily Routines"},{"location":"DailyRoutine/#waypoints-as-rough-location-markers","text":"As you can see in the code snipped above, there is an interesting comment, // mit Grim : TA_Smalltalk (..., \"OCR_CAMPFIRE_A_MOVEMENT1\" ) // mit Grim This says, that Diego should to Smalltalk with the Npc Grim . However, that is just a code comment. The TA_Smalltalk activity just searches for any nearby Npc to do smalltalk with. In Grims Daily Routine, there is a similar entry, which makes them both go to the same location to meet there every day. Both of them just don't know who to expect there and meet every day by \"chance\", which is kinda funny. This also applies to states where interactive items are involved. They usually just say Go to some location and see if you can find an Amboss to work on . If that is already occupied, the Npc may do something else instead.","title":"Waypoints as rough location markers"},{"location":"DailyRoutine/#script-states","text":"This is a complex topic, which I need to quickly go over for daily routines. However, Script States are also used for other purposes extensively. Each of the Daily-Routine actions registered for that Npc executes a Script State on that Npc when its time has come. For example, lets look at this line again: TA_Smalltalk ( 10 , 00 , 12 , 00 , \"OCR_CAMPFIRE_A_MOVEMENT1\" ); //mit Grim On execution, this registers the Script State ZS_SMALLTALK from 10:00 to 12:00 at the location OCR_CAMPFIRE_A_MOVEMENT1 in Diegos Daily Routine. ZS_SMALLTALK is then defined here . Each Script State can have the following script functionality: An init function, called once when the state is started A loop function, called every frame while the state is active and there is nothing else to do. This function can also decide whether the state should continue. An end function, called when the state has ended. If the time goes on and a different Daily Routine action gets activated, the current state is canceled gracefully and the next state is started. Example For ZS_SMALLTALK , you can break that down in the following (as seen from the Npcs perspecitve): Begin the state: Set me to slow-walkmode. If I am not already on a Freepoint called SMALLTALK , let me go to the Waypoint registered in the Daily Routine. Then, let me go to the next unoccupied Freepoint called SMALLTALK . Face into the direction of the Freepoint. Then, when there is nothing else to do: On this particular Script-State, there is not action when the state ended.","title":"Script States"},{"location":"DailyRoutine/#interruptions","text":"Execution of the Script State belonging to the current Daily Routine action is interrupted by assigning any other Script State to the Npc, ie. when when taking damage or talking to the Npc, which starts ZS_TALK . Once the non-routine Script State is over and the Npc has nothing to do anymore, the Daily Routine is started again.","title":"Interruptions"},{"location":"DailyRoutine/#weird-daily-routines","text":"There are some gameplay elements you wouldn't think of as a Daily Routine, such as Following the Player Guiding the player to some location","title":"Weird Daily Routines"},{"location":"DialogueSystem/","text":"Dialogue-System Fig. 1: Dialogue Lines ( Source ) In Gothics Dialogue-System, everything revolves around Information -Instances and their Conditions . Dialogue Lines Every Dialogue Line you can see in Fig. 1 is an Information -Instance, which has the following properties: Description The text the player sees in the dialogue menu Priority Top to Bottom ordering Is Permanent? Whether the line is always shown and can be used multiple times. Is Important? Whether the Npc should start talking to the player automatically to tell him this information. Guards usually do this to stop you. Condition-Function If this script function returns True , this information is shown in the dialogue menu. Evaluated every time the Dialogue Menu is loaded. Info-Function Script function to be called when this information got selected in the dialogue menu. Every time the dialogue menu is loaded, the Condition function is called to check whether the dialogue line should be available in the menu. Whenever you as the Player choses a dialogue line in the menu, the Hero remembers that you chose that line. This is because only the originator of the conversation stores the selected information-lines. Dialogue-lines already known by the player and not flagged as Permanent will not show up in the menu anymore. Note If two Npcs would talk to each other, the one starting the conversation would also store information-lines they chose. However, since Gothic is a Single Player game, that never happens. The scripts can then check whether the Hero knows a certain information like so : // Equals to \"Has the player ever chosen that dialogue line?\" if ( Npc_KnowsInfo ( hero , DIA_BaalOrun_GotWeed )) { // ... do something } Saying something Letting the Characters actually say something is done by enqueuing dialogue lines into the Action Queue by calling AI_Output from the Info-Function like so: AI_Output ( hero , self , \"Info_Diego_Brief_15_00\" ); //Ich habe einen Brief f\u00fcr den obersten Feuermagier. AI_Output ( self , hero , \"Info_Diego_Brief_11_01\" ); //So...? AI_Output ( hero , self , \"Info_Diego_Brief_15_02\" ); //Ein Magier hat ihn mir gegeben, kurz bevor sie mich reingeworfen haben. AI_Output ( self , hero , \"Info_Diego_Brief_11_03\" ); //Du kannst von Gl\u00fcck sagen, dass ich mich bei den Magiern nicht mehr blicken lassen kann. Jeder andere wird dir mit Freude f\u00fcr Lets break it down: The first two parameters are who is saying the line to who. This is a dialogue between Diego and the Hero, so self refers to Diego in this case. Note how they switch back and forth! The third Parameter is a unique reference to the output-database, which stores the actual dialogue text and the WAV-file to play. When each of these AI_Outputs is pushed into the Action Queue of the talking character, the character which is being talked to explicitly checks whether a conversation is active and blocks its own Action-Queue while someone else says something. Note The original workflow for these files incorporated parsing the comments behind the AI_Output and putting them into the database. Example - Drug Monopol In this dialogue, the player gets asked by Cor Kalom to stop a Swampweed production of the New Camp. This is the Information -Instance : INSTANCE Info_Kalom_DrugMonopol ( C_INFO ) { npc = GUR_1201_CorKalom ; condition = Info_Kalom_DrugMonopol_Condition ; information = Info_Kalom_DrugMonopol_Info ; permanent = 0 ; description = \"Hast DU noch eine Aufgabe f\u00fcr mich?\" ; }; Here, the condition checks, whether the player is joined the Swamp Camp and is now a Novice: FUNC INT Info_Kalom_DrugMonopol_Condition () { if ( Npc_GetTrueGuild ( other ) == GIL_NOV ) { return 1 ; } // implicit return 0 } When the Player selected the dialogue line of this Information -Instance, this function gets called: FUNC VOID Info_Kalom_DrugMonopol_Info () { AI_Output ( other , self , \"Mis_1_Psi_Kalom_DrugMonopol_15_00\" ); // ... AI_Output ( self , other , \"Mis_1_Psi_Kalom_DrugMonopol_10_01\" ); // ... // ... <snip> } Once the Player has selected the dialogue line, the Hero remembers it. Other scripts can then check whether that dialogue line was ever chosen by the player via a call to Npc_KnowsInfo . Dialogue-lines already known by the player and not flagged as Permanent will not show up in the menu anymore. Note Notice how in Kor Kaloms AI_Output the two parameters are other and self , while the dialogue of Diego listed above explicitly used hero . I can imagine that is because Kor Kaloms Dialogue was made multiplayer-ready!","title":"Dialogue System"},{"location":"DialogueSystem/#dialogue-system","text":"Fig. 1: Dialogue Lines ( Source ) In Gothics Dialogue-System, everything revolves around Information -Instances and their Conditions .","title":"Dialogue-System"},{"location":"DialogueSystem/#dialogue-lines","text":"Every Dialogue Line you can see in Fig. 1 is an Information -Instance, which has the following properties: Description The text the player sees in the dialogue menu Priority Top to Bottom ordering Is Permanent? Whether the line is always shown and can be used multiple times. Is Important? Whether the Npc should start talking to the player automatically to tell him this information. Guards usually do this to stop you. Condition-Function If this script function returns True , this information is shown in the dialogue menu. Evaluated every time the Dialogue Menu is loaded. Info-Function Script function to be called when this information got selected in the dialogue menu. Every time the dialogue menu is loaded, the Condition function is called to check whether the dialogue line should be available in the menu. Whenever you as the Player choses a dialogue line in the menu, the Hero remembers that you chose that line. This is because only the originator of the conversation stores the selected information-lines. Dialogue-lines already known by the player and not flagged as Permanent will not show up in the menu anymore. Note If two Npcs would talk to each other, the one starting the conversation would also store information-lines they chose. However, since Gothic is a Single Player game, that never happens. The scripts can then check whether the Hero knows a certain information like so : // Equals to \"Has the player ever chosen that dialogue line?\" if ( Npc_KnowsInfo ( hero , DIA_BaalOrun_GotWeed )) { // ... do something }","title":"Dialogue Lines"},{"location":"DialogueSystem/#saying-something","text":"Letting the Characters actually say something is done by enqueuing dialogue lines into the Action Queue by calling AI_Output from the Info-Function like so: AI_Output ( hero , self , \"Info_Diego_Brief_15_00\" ); //Ich habe einen Brief f\u00fcr den obersten Feuermagier. AI_Output ( self , hero , \"Info_Diego_Brief_11_01\" ); //So...? AI_Output ( hero , self , \"Info_Diego_Brief_15_02\" ); //Ein Magier hat ihn mir gegeben, kurz bevor sie mich reingeworfen haben. AI_Output ( self , hero , \"Info_Diego_Brief_11_03\" ); //Du kannst von Gl\u00fcck sagen, dass ich mich bei den Magiern nicht mehr blicken lassen kann. Jeder andere wird dir mit Freude f\u00fcr Lets break it down: The first two parameters are who is saying the line to who. This is a dialogue between Diego and the Hero, so self refers to Diego in this case. Note how they switch back and forth! The third Parameter is a unique reference to the output-database, which stores the actual dialogue text and the WAV-file to play. When each of these AI_Outputs is pushed into the Action Queue of the talking character, the character which is being talked to explicitly checks whether a conversation is active and blocks its own Action-Queue while someone else says something. Note The original workflow for these files incorporated parsing the comments behind the AI_Output and putting them into the database.","title":"Saying something"},{"location":"DialogueSystem/#example-drug-monopol","text":"In this dialogue, the player gets asked by Cor Kalom to stop a Swampweed production of the New Camp. This is the Information -Instance : INSTANCE Info_Kalom_DrugMonopol ( C_INFO ) { npc = GUR_1201_CorKalom ; condition = Info_Kalom_DrugMonopol_Condition ; information = Info_Kalom_DrugMonopol_Info ; permanent = 0 ; description = \"Hast DU noch eine Aufgabe f\u00fcr mich?\" ; }; Here, the condition checks, whether the player is joined the Swamp Camp and is now a Novice: FUNC INT Info_Kalom_DrugMonopol_Condition () { if ( Npc_GetTrueGuild ( other ) == GIL_NOV ) { return 1 ; } // implicit return 0 } When the Player selected the dialogue line of this Information -Instance, this function gets called: FUNC VOID Info_Kalom_DrugMonopol_Info () { AI_Output ( other , self , \"Mis_1_Psi_Kalom_DrugMonopol_15_00\" ); // ... AI_Output ( self , other , \"Mis_1_Psi_Kalom_DrugMonopol_10_01\" ); // ... // ... <snip> } Once the Player has selected the dialogue line, the Hero remembers it. Other scripts can then check whether that dialogue line was ever chosen by the player via a call to Npc_KnowsInfo . Dialogue-lines already known by the player and not flagged as Permanent will not show up in the menu anymore. Note Notice how in Kor Kaloms AI_Output the two parameters are other and self , while the dialogue of Diego listed above explicitly used hero . I can imagine that is because Kor Kaloms Dialogue was made multiplayer-ready!","title":"Example - Drug Monopol"},{"location":"EventMessages/","text":"Full List of Gothic Event-Message Types and Subtypes Taken from REGoth-bs . Weapon DrawWeapon DrawWeapon1 DrawWeapon2 RemoveWeapon RemoveWeapon1 RemoveWeapon2 ChooseWeapon ForceRemoveWeapon Attack EquipBestWeapon EquipBestArmor UnequipWeapons UnequipArmor EquipArmor Movement RobustTrace GotoPos GotoVob GoRoute Turn TurnToPos TurnToVob TurnAway Jump SetWalkMode WhirlAround Standup CanSeeNpc Strafe GotoFP Dodge BeamTo AlignToFP Attack AttackForward AttackLeft AttackRight AttackRun AttackFinish Parade AimAt ShootAt StopAim Defend AttackBow AttackMagic Manipulate TakeVob DropVob ThrowVob Exchange UseMob UseItem InsertInteractItem RemoveInteractItem CreateInteractItem DestroyInteractItem PlaceInteractItem ExchangeInteractItem UseMobWithItem CallScript EquipItem UseItemToState TakeMob DropMob Conversation PlayAniSound PlayAni PlaySound LookAt Output OutputMonolog OutputEnd Cutscene WaitTillEnd Ask WaitForQuestion StopLookAt StopPointAt PointAt QuickLook PlayAni_NoOverlay PlayAni_Face ProcessInfos StopProcessInfos OutputSVM_Overlay SndPlay SndPlay3d PrintScreen StartFx StopFx Magic Open Close Move Invest Cast SetLevel ShowSymbol SetFrontSpell CastSpell Ready Unready Mob StartInteraction StartStatechange EndInteraction Unlock Lock Callscript","title":"Full List of Gothic Event-Message Types and Subtypes"},{"location":"EventMessages/#full-list-of-gothic-event-message-types-and-subtypes","text":"Taken from REGoth-bs .","title":"Full List of Gothic Event-Message Types and Subtypes"},{"location":"EventMessages/#weapon","text":"DrawWeapon DrawWeapon1 DrawWeapon2 RemoveWeapon RemoveWeapon1 RemoveWeapon2 ChooseWeapon ForceRemoveWeapon Attack EquipBestWeapon EquipBestArmor UnequipWeapons UnequipArmor EquipArmor","title":"Weapon"},{"location":"EventMessages/#movement","text":"RobustTrace GotoPos GotoVob GoRoute Turn TurnToPos TurnToVob TurnAway Jump SetWalkMode WhirlAround Standup CanSeeNpc Strafe GotoFP Dodge BeamTo AlignToFP","title":"Movement"},{"location":"EventMessages/#attack","text":"AttackForward AttackLeft AttackRight AttackRun AttackFinish Parade AimAt ShootAt StopAim Defend AttackBow AttackMagic","title":"Attack"},{"location":"EventMessages/#manipulate","text":"TakeVob DropVob ThrowVob Exchange UseMob UseItem InsertInteractItem RemoveInteractItem CreateInteractItem DestroyInteractItem PlaceInteractItem ExchangeInteractItem UseMobWithItem CallScript EquipItem UseItemToState TakeMob DropMob","title":"Manipulate"},{"location":"EventMessages/#conversation","text":"PlayAniSound PlayAni PlaySound LookAt Output OutputMonolog OutputEnd Cutscene WaitTillEnd Ask WaitForQuestion StopLookAt StopPointAt PointAt QuickLook PlayAni_NoOverlay PlayAni_Face ProcessInfos StopProcessInfos OutputSVM_Overlay SndPlay SndPlay3d PrintScreen StartFx StopFx","title":"Conversation"},{"location":"EventMessages/#magic","text":"Open Close Move Invest Cast SetLevel ShowSymbol SetFrontSpell CastSpell Ready Unready","title":"Magic"},{"location":"EventMessages/#mob","text":"StartInteraction StartStatechange EndInteraction Unlock Lock Callscript","title":"Mob"},{"location":"QuestLog/","text":"Tracking active Quests Fig. 1: Quest Log ( Source ) Tracking active quests is handled a bit weird by Gothic. Scripts have write-access to the players Quest-Log, but they cannot read back the quest status. Thus, a global boolean variable was created for most quests to track whether its active. Additionally, the Quest-Log is kept in sync : Homer_DamLurker = LOG_RUNNING ; // Global variable Log_CreateTopic ( CH1_DamLurker , LOG_MISSION ); Log_SetTopicStatus ( CH1_DamLurker , LOG_RUNNING ); I can't think of a reason other than the Quest-Log being implemented much later into development for this to make sense. Diary In the game, the Quest Log is actually the hero's diary. On script-side, the functions Log_CreateTopic : Add Topic and choose between Mission or Note Log_SetTopicStatus : Set a Topic to Running, Success, Failed, Obsolete Log_AddEntry : Add a piece of text to a Topic are used to update the diary. Depending on the topics status, they are sorted into the categories. Interestingly, the Obsolete categories is actually obsolete and not used by the game. Topics using that category will not show up in the Diary. Note The Diary is read-only, scripts are using global variables to manually keep track whether a quest is active. A full list of all quest topic names can be found in the scripts .","title":"Quest Log"},{"location":"QuestLog/#tracking-active-quests","text":"Fig. 1: Quest Log ( Source ) Tracking active quests is handled a bit weird by Gothic. Scripts have write-access to the players Quest-Log, but they cannot read back the quest status. Thus, a global boolean variable was created for most quests to track whether its active. Additionally, the Quest-Log is kept in sync : Homer_DamLurker = LOG_RUNNING ; // Global variable Log_CreateTopic ( CH1_DamLurker , LOG_MISSION ); Log_SetTopicStatus ( CH1_DamLurker , LOG_RUNNING ); I can't think of a reason other than the Quest-Log being implemented much later into development for this to make sense.","title":"Tracking active Quests"},{"location":"QuestLog/#diary","text":"In the game, the Quest Log is actually the hero's diary. On script-side, the functions Log_CreateTopic : Add Topic and choose between Mission or Note Log_SetTopicStatus : Set a Topic to Running, Success, Failed, Obsolete Log_AddEntry : Add a piece of text to a Topic are used to update the diary. Depending on the topics status, they are sorted into the categories. Interestingly, the Obsolete categories is actually obsolete and not used by the game. Topics using that category will not show up in the Diary. Note The Diary is read-only, scripts are using global variables to manually keep track whether a quest is active. A full list of all quest topic names can be found in the scripts .","title":"Diary"},{"location":"Rain/","text":"Rain On the (almost) yearly Moddertreffen , a Community Meetup, I have been told, that while the programmers thought Rain was important for an authentic feeling, management (or the publisher, can't remember) didn't think so. The legend goes that some members of the team met at the weekend and implemented rain into the engine, because it felt like the right thing to do. Management liked it (or didn't care) and they left it in. When does it rain? The two main properties for controlling the rain are its Start and Stop times. There are no limitations on when the rain happens during the day (or night). The minimum duration for rain is 1 hour. The maximum duration is about 2.5 hours. The following special cases exist: The first rain-event always happens between 16:30 and 17:30, so that the player will definitely see it. On the first 3 Days, it only rains. After those, there is also lightning with a chance of 40%.","title":"Rain"},{"location":"Rain/#rain","text":"On the (almost) yearly Moddertreffen , a Community Meetup, I have been told, that while the programmers thought Rain was important for an authentic feeling, management (or the publisher, can't remember) didn't think so. The legend goes that some members of the team met at the weekend and implemented rain into the engine, because it felt like the right thing to do. Management liked it (or didn't care) and they left it in.","title":"Rain"},{"location":"Rain/#when-does-it-rain","text":"The two main properties for controlling the rain are its Start and Stop times. There are no limitations on when the rain happens during the day (or night). The minimum duration for rain is 1 hour. The maximum duration is about 2.5 hours. The following special cases exist: The first rain-event always happens between 16:30 and 17:30, so that the player will definitely see it. On the first 3 Days, it only rains. After those, there is also lightning with a chance of 40%.","title":"When does it rain?"},{"location":"fight-ai/","text":"Fight AI Both monsters and humans use the same code for their Fight AI, which behaves differently depending on the weapons the character has access to. Note Monsters are always in Fist-Mode , even when not attacking. An attacking Scavenger is the same as a fistpunch for the Fight-AI. Situations Which move the character should do next is depending on the situation it finds itself in. Here is a complete list of all situations: Priority 1: Reacting to enemy actions Enemy is about to hit me! Enemy is doing a storm-attack! I got the enemy in focus and they're turning towards me to hit me! Priority 2: Enemy is in melee range I'm in a weapon-combo I'm running towards my enemy I'm strafing I'm not doing anything, but got the enemy in focus Enemy is close, but not in focus! Priority 3: Enemy is within walking distance (melee-range * 3) I'm in a weapon-combo, but the enemy is just out of reach! I'm running towards my enemy, but he's still just out of reach! I'm strafing and the enemy is just out of reach Not doing anything while the enemy is just out of reach. Enemy just out of reach, but not focused! Priority 4: Enemy is in far-fighting-range (Bows, Crossbows, Magic) I have the enemy in focus! Enemy is not focused, but within far-fighting-range! All those situations are checked from top to bottom, in the order they are given here. Depending on the first match, the next move is determined. Info Determination of the next move for a situation can also result in trying the next situation! Possible fight moves The following fight moves can be done by the characters: Movement: Run Run back Jump back Turn Strafe Turn to hit Stand up Attacks: Attack [When walking: Stormattack] otherwise [Left or Right] Side attack [Left \u2192 Right] Front attack [Left \u2192 Forward] or [Right \u2192 Forward] Triple attack [Forward \u2192 Right \u2192 Left] or [Left \u2192 Right \u2192 Forward] Whirl attack [Left \u2192 Right \u2192 Left \u2192 Right] Master attack [Left \u2192 Right \u2192 4x Forward] Parade Storm-Attack Attack Status: Prehit Combozone Posthit Character status: On ground Stumble Wait (short, 200ms) Wait (long, 400ms) Character tactics Now with all situations and fight moves defined, we can look into how different fight-tactics are realized. Different tactics are used depending on the type of character and skill-level. The tactics are defined in the script files . For each tactic, there is a set of script instances, one for each situation . Here is an excerpt of the Human-Master tactic : INSTANCE FA_ENEMY_STORMPREHIT_4 ( C_FightAI ) { move [ 0 ] = MOVE_STRAFE ; }; INSTANCE FA_MY_W_COMBO_4 ( C_FightAI ) { move [ 0 ] = MOVE_WHIRLATTACK ; }; INSTANCE FA_MY_W_RUNTO_4 ( C_FightAI ) { move [ 0 ] = MOVE_RUN ; }; Notice the 4 in the instances name. This number is the tactics index. The instance name itself encodes the situation to which it should apply. Each of these instances can hold up to 6 moves. One of them is randomly chosen once the character is in that situation. Example Here is what a skeleton would do, if it has the enemy in focus but is not doing anything otherwise: INSTANCE FA_MY_W_FOCUS_17 ( C_FightAI ) { move [ 0 ] = MOVE_WAIT ; move [ 1 ] = MOVE_STRAFE ; move [ 2 ] = MOVE_WAIT ; move [ 3 ] = MOVE_WAIT ; move [ 4 ] = MOVE_ATTACK ; move [ 5 ] = MOVE_ATTACK ; }; With a chance of... \u00bd it will wait for 200 Milliseconds \u2153 it will attack \u2159 it will strafe in a random direction The order in which the moves are specified does not matter. The engine simply chooses one random move.","title":"Fight AI"},{"location":"fight-ai/#fight-ai","text":"Both monsters and humans use the same code for their Fight AI, which behaves differently depending on the weapons the character has access to. Note Monsters are always in Fist-Mode , even when not attacking. An attacking Scavenger is the same as a fistpunch for the Fight-AI.","title":"Fight AI"},{"location":"fight-ai/#situations","text":"Which move the character should do next is depending on the situation it finds itself in. Here is a complete list of all situations: Priority 1: Reacting to enemy actions Enemy is about to hit me! Enemy is doing a storm-attack! I got the enemy in focus and they're turning towards me to hit me! Priority 2: Enemy is in melee range I'm in a weapon-combo I'm running towards my enemy I'm strafing I'm not doing anything, but got the enemy in focus Enemy is close, but not in focus! Priority 3: Enemy is within walking distance (melee-range * 3) I'm in a weapon-combo, but the enemy is just out of reach! I'm running towards my enemy, but he's still just out of reach! I'm strafing and the enemy is just out of reach Not doing anything while the enemy is just out of reach. Enemy just out of reach, but not focused! Priority 4: Enemy is in far-fighting-range (Bows, Crossbows, Magic) I have the enemy in focus! Enemy is not focused, but within far-fighting-range! All those situations are checked from top to bottom, in the order they are given here. Depending on the first match, the next move is determined. Info Determination of the next move for a situation can also result in trying the next situation!","title":"Situations"},{"location":"fight-ai/#possible-fight-moves","text":"The following fight moves can be done by the characters: Movement: Run Run back Jump back Turn Strafe Turn to hit Stand up Attacks: Attack [When walking: Stormattack] otherwise [Left or Right] Side attack [Left \u2192 Right] Front attack [Left \u2192 Forward] or [Right \u2192 Forward] Triple attack [Forward \u2192 Right \u2192 Left] or [Left \u2192 Right \u2192 Forward] Whirl attack [Left \u2192 Right \u2192 Left \u2192 Right] Master attack [Left \u2192 Right \u2192 4x Forward] Parade Storm-Attack Attack Status: Prehit Combozone Posthit Character status: On ground Stumble Wait (short, 200ms) Wait (long, 400ms)","title":"Possible fight moves"},{"location":"fight-ai/#character-tactics","text":"Now with all situations and fight moves defined, we can look into how different fight-tactics are realized. Different tactics are used depending on the type of character and skill-level. The tactics are defined in the script files . For each tactic, there is a set of script instances, one for each situation . Here is an excerpt of the Human-Master tactic : INSTANCE FA_ENEMY_STORMPREHIT_4 ( C_FightAI ) { move [ 0 ] = MOVE_STRAFE ; }; INSTANCE FA_MY_W_COMBO_4 ( C_FightAI ) { move [ 0 ] = MOVE_WHIRLATTACK ; }; INSTANCE FA_MY_W_RUNTO_4 ( C_FightAI ) { move [ 0 ] = MOVE_RUN ; }; Notice the 4 in the instances name. This number is the tactics index. The instance name itself encodes the situation to which it should apply. Each of these instances can hold up to 6 moves. One of them is randomly chosen once the character is in that situation. Example Here is what a skeleton would do, if it has the enemy in focus but is not doing anything otherwise: INSTANCE FA_MY_W_FOCUS_17 ( C_FightAI ) { move [ 0 ] = MOVE_WAIT ; move [ 1 ] = MOVE_STRAFE ; move [ 2 ] = MOVE_WAIT ; move [ 3 ] = MOVE_WAIT ; move [ 4 ] = MOVE_ATTACK ; move [ 5 ] = MOVE_ATTACK ; }; With a chance of... \u00bd it will wait for 200 Milliseconds \u2153 it will attack \u2159 it will strafe in a random direction The order in which the moves are specified does not matter. The engine simply chooses one random move.","title":"Character tactics"},{"location":"monster-ai/","text":"Monster AI As hinted in the Chapter Daily Routine , Monsters do not use the same Daily Routine code Humans are using. Each Monster is actually using the Monster Scheduler . Monster Scheduler The following start and end times can be set for each type of Monster and are relevant to the scheduler: Sleep time Rest time Roaming time Eat-Ground time Wusel time 1 Each of them can be set as being always active , but they are prioritized in the order given above, top to bottom. Example When Roaming is set to be always active , but the time for Sleep is satisfied, the Monster will go Sleeping, since that has a higher priority. Depending on the ingame clock time, one of the matching sub-states is entered. If none of the times are satisfied, a default state is entered. All states will wait a random time up to 1 Second so that nearby Monsters will not start their actions at the exact same time. Sleep State The following effects are applied when the state is initialized: Monsters perception time is increased to 2 Seconds, so it takes slightly longer to notice things going on around it. Predators will not prioritize this Monster in this state. (Why ever that is) The Monster is told to walk (instead of run). Then, the following actions are executed: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before laying down. Then, the Monster will walk to the next unoccupied Freepoint FP_SLEEP if possible. A \"looking around, making sure everything is ok\" animation is played The Monster plays its Lay down to sleep animation. Then, the state is looped until the sleep time is not satisfied anymore. Rest State The following effects are applied when the state is initialized: Monsters perception time is increased to 2 Seconds, so it takes slightly longer to notice things going on around it. Predators will prioritize this Monster in this state. The Monster is told to walk (instead of run). Then, the following actions are executed: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before resting. Then, the Monster will walk to the next unoccupied Freepoint FP_ROAM if possible. After initialization, on each loop update: One of three random roam (yes, roaming, not resting) animations may be started with a chance of roughly 0.5%. Info There is a bug in the original scripts here. The code rolls the random number via Hlp_Random(2) , which is implemented via the standard C construct rand() % max . However, the modulo operation will return a number from 0 to max - 1 ! Therefore, Hlp_Random(2) will only return either 0 or 1 . This script code will never choose the third animation. Roaming State The following effects are applied when the state is initialized: The Monster is told to walk (instead of run). Then, the following actions are executed on every state-loop update: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before roaming. With a chance of 20%, walk to the next unoccupied Freepoint FP_ROAM . If no such Freepoint exists, the Monster will walk to the closest Waypoint and then to the Waypoint after that. If the chance was not met, one of three random roam animations may be started with a chance of roughly 0.5%. Info There is a bug in the original scripts here. The code rolls the random number via Hlp_Random(2) , which is implemented via the standard C construct rand() % max . However, the modulo operation will return a number from 0 to max - 1 ! Therefore, Hlp_Random(2) will only return either 0 or 1 . This script code will never choose the third animation. Eat-Ground State The following effects are applied when the state is initialized: Monsters perception time is increased to 2 Seconds, so it takes slightly longer to notice things going on around it. Predators will prioritize this Monster in this state. The Monster is told to walk (instead of run). Then, the following actions are executed: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before eating. Then, the Monster will walk to the next unoccupied Freepoint FP_ROAM if possible. At last, 3 eating animations are scheduled, each playing for a random time of up to 8 seconds. There are no actions in the loop update. Wusel State The following effects are applied when the state is initialized: The Monster is told to run (instead of walk). The loop update is the same as in the Resting State: The Monster will walk to random locations. Default State While in this state, the Monster will simply turn towards the Waypoint it was spawned at but stay still otherwise. Prey and Predator Some Monsters can have Prey and Predator relationships between each other. In Gothic I, only two of those relationships exist: Prey Predator Note Scavenger Snapper Molerat Wolf (Goblin) (Lurker) Commented out (Bloodfly) (Scavenger) Commented out Reacting to Damage Once a Monster is being hit, it choses a different action depending on whether the attacker is a predator: If the Monster is being hunted by a predator, it enters the Fleeing state. Otherwise, it starts to defend itself by attacking back . Monsters can also notice when any other Npc or Monster is damaged: If the attacked Monster is of the same species and is being attacked by a predator, the Monster will also flee . If a friend is being attacked, and the attacker is not friends with the monster, the monster will help its mate . If a friend attacks something else, which is not friends with the monster, the monster will also help its mate in the fight . If the monster is in a fight already, the rules are a bit simpler: If the monster is being damaged by a predator, it flees . If the monster is damaged by the hero, it forgets everything else and attacks him. Note Attacking summoned monsters will also react to the summoner taking damage. Fleeing State The following effects are applied when the state is initialized: The Monster is told to run (instead of walk) During the loop update, the following actions are executed: If the attacker is within 2 a range of meters, the Npc finds the next Waypoint in the opposite direction of the attacker and sprints towards it. Otherwise, it remembers the nearest Waypoint as \"Home\" and stays there. Fleeing is done. Attacking State The following effects are applied when the state is initialized: The Monster is told to run (instead of walk) The target is determined and locked in. A warning is sent to nearby monsters (Makes the target flee or let the pack help in the attack) During the loop update, the following actions are executed: If the target is dead, the attack is over and the monster will start eating the target . 2 If the target is running away, and the time the monster is allowed to follow is passed, the attack is canceled. If the target is running away through water, the attack is canceled right away (depending on the monsters properties). 3 When the target became invalid or is unable to fight (ie. went unconscious), the monster will start eating if it is classified as HUNTER or (if it isn't a HUNTER ) try to find something else to attack. If there is nothing, the attack is cancelled. When an attack got cancelled, the monster will: Play the Warning animation Wait for 1 second on the spot where it's standing so the player has a chance to get away. Note If the target is Invincible , it is not attacked. This is a dirty hack to ignore characters who are talking right now. Hard to translate German word for a swarm of sth. walking around aimlessly. (To bustle around?) \u21a9 The monster may wander off to a different freepoint or waypoint as specified in the Eat Ground State , which I suppose is not intended. \u21a9 Orcs HATE water! \u21a9","title":"Monster AI"},{"location":"monster-ai/#monster-ai","text":"As hinted in the Chapter Daily Routine , Monsters do not use the same Daily Routine code Humans are using. Each Monster is actually using the Monster Scheduler .","title":"Monster AI"},{"location":"monster-ai/#monster-scheduler","text":"The following start and end times can be set for each type of Monster and are relevant to the scheduler: Sleep time Rest time Roaming time Eat-Ground time Wusel time 1 Each of them can be set as being always active , but they are prioritized in the order given above, top to bottom. Example When Roaming is set to be always active , but the time for Sleep is satisfied, the Monster will go Sleeping, since that has a higher priority. Depending on the ingame clock time, one of the matching sub-states is entered. If none of the times are satisfied, a default state is entered. All states will wait a random time up to 1 Second so that nearby Monsters will not start their actions at the exact same time.","title":"Monster Scheduler"},{"location":"monster-ai/#sleep-state","text":"The following effects are applied when the state is initialized: Monsters perception time is increased to 2 Seconds, so it takes slightly longer to notice things going on around it. Predators will not prioritize this Monster in this state. (Why ever that is) The Monster is told to walk (instead of run). Then, the following actions are executed: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before laying down. Then, the Monster will walk to the next unoccupied Freepoint FP_SLEEP if possible. A \"looking around, making sure everything is ok\" animation is played The Monster plays its Lay down to sleep animation. Then, the state is looped until the sleep time is not satisfied anymore.","title":"Sleep State"},{"location":"monster-ai/#rest-state","text":"The following effects are applied when the state is initialized: Monsters perception time is increased to 2 Seconds, so it takes slightly longer to notice things going on around it. Predators will prioritize this Monster in this state. The Monster is told to walk (instead of run). Then, the following actions are executed: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before resting. Then, the Monster will walk to the next unoccupied Freepoint FP_ROAM if possible. After initialization, on each loop update: One of three random roam (yes, roaming, not resting) animations may be started with a chance of roughly 0.5%. Info There is a bug in the original scripts here. The code rolls the random number via Hlp_Random(2) , which is implemented via the standard C construct rand() % max . However, the modulo operation will return a number from 0 to max - 1 ! Therefore, Hlp_Random(2) will only return either 0 or 1 . This script code will never choose the third animation.","title":"Rest State"},{"location":"monster-ai/#roaming-state","text":"The following effects are applied when the state is initialized: The Monster is told to walk (instead of run). Then, the following actions are executed on every state-loop update: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before roaming. With a chance of 20%, walk to the next unoccupied Freepoint FP_ROAM . If no such Freepoint exists, the Monster will walk to the closest Waypoint and then to the Waypoint after that. If the chance was not met, one of three random roam animations may be started with a chance of roughly 0.5%. Info There is a bug in the original scripts here. The code rolls the random number via Hlp_Random(2) , which is implemented via the standard C construct rand() % max . However, the modulo operation will return a number from 0 to max - 1 ! Therefore, Hlp_Random(2) will only return either 0 or 1 . This script code will never choose the third animation.","title":"Roaming State"},{"location":"monster-ai/#eat-ground-state","text":"The following effects are applied when the state is initialized: Monsters perception time is increased to 2 Seconds, so it takes slightly longer to notice things going on around it. Predators will prioritize this Monster in this state. The Monster is told to walk (instead of run). Then, the following actions are executed: If the closest waypoint is not the one where it was spawned, the Monster will run \"home\" before eating. Then, the Monster will walk to the next unoccupied Freepoint FP_ROAM if possible. At last, 3 eating animations are scheduled, each playing for a random time of up to 8 seconds. There are no actions in the loop update.","title":"Eat-Ground State"},{"location":"monster-ai/#wusel-state","text":"The following effects are applied when the state is initialized: The Monster is told to run (instead of walk). The loop update is the same as in the Resting State: The Monster will walk to random locations.","title":"Wusel State"},{"location":"monster-ai/#default-state","text":"While in this state, the Monster will simply turn towards the Waypoint it was spawned at but stay still otherwise.","title":"Default State"},{"location":"monster-ai/#prey-and-predator","text":"Some Monsters can have Prey and Predator relationships between each other. In Gothic I, only two of those relationships exist: Prey Predator Note Scavenger Snapper Molerat Wolf (Goblin) (Lurker) Commented out (Bloodfly) (Scavenger) Commented out","title":"Prey and Predator"},{"location":"monster-ai/#reacting-to-damage","text":"Once a Monster is being hit, it choses a different action depending on whether the attacker is a predator: If the Monster is being hunted by a predator, it enters the Fleeing state. Otherwise, it starts to defend itself by attacking back . Monsters can also notice when any other Npc or Monster is damaged: If the attacked Monster is of the same species and is being attacked by a predator, the Monster will also flee . If a friend is being attacked, and the attacker is not friends with the monster, the monster will help its mate . If a friend attacks something else, which is not friends with the monster, the monster will also help its mate in the fight . If the monster is in a fight already, the rules are a bit simpler: If the monster is being damaged by a predator, it flees . If the monster is damaged by the hero, it forgets everything else and attacks him. Note Attacking summoned monsters will also react to the summoner taking damage.","title":"Reacting to Damage"},{"location":"monster-ai/#fleeing-state","text":"The following effects are applied when the state is initialized: The Monster is told to run (instead of walk) During the loop update, the following actions are executed: If the attacker is within 2 a range of meters, the Npc finds the next Waypoint in the opposite direction of the attacker and sprints towards it. Otherwise, it remembers the nearest Waypoint as \"Home\" and stays there. Fleeing is done.","title":"Fleeing State"},{"location":"monster-ai/#attacking-state","text":"The following effects are applied when the state is initialized: The Monster is told to run (instead of walk) The target is determined and locked in. A warning is sent to nearby monsters (Makes the target flee or let the pack help in the attack) During the loop update, the following actions are executed: If the target is dead, the attack is over and the monster will start eating the target . 2 If the target is running away, and the time the monster is allowed to follow is passed, the attack is canceled. If the target is running away through water, the attack is canceled right away (depending on the monsters properties). 3 When the target became invalid or is unable to fight (ie. went unconscious), the monster will start eating if it is classified as HUNTER or (if it isn't a HUNTER ) try to find something else to attack. If there is nothing, the attack is cancelled. When an attack got cancelled, the monster will: Play the Warning animation Wait for 1 second on the spot where it's standing so the player has a chance to get away. Note If the target is Invincible , it is not attacked. This is a dirty hack to ignore characters who are talking right now. Hard to translate German word for a swarm of sth. walking around aimlessly. (To bustle around?) \u21a9 The monster may wander off to a different freepoint or waypoint as specified in the Eat Ground State , which I suppose is not intended. \u21a9 Orcs HATE water! \u21a9","title":"Attacking State"},{"location":"objects/item/","text":"Item Everything you can pick up from the ground is using the Item class. They have the following important properties: Display name Item category (Potion, weapon, ...) Value in Gold/Ore Description Text Then, they all have properties regarding consumables, armor, weapons, and so on, which are just disabled by default. That could be: Script function to run on use, equip and unequip New Visual for the character who equipped this (for armors) Magic cycle and script functions Guild and fake-Guild Spell range For a full list, see this . Depending on the item category, some of these are used while the others are ignored. I imagine this could have been made nicer be creating more classes, and not shoving everything into one base class... Script Dependency during World Load Items can be spawned via script, but usually are loaded straight from the world-file ( .zen ). However, the visual of the item is always defined in the script instance! For example, let's take a look at the Health Potion instance definition (see Mesh to use comment): INSTANCE ItFo_Potion_Health_01 ( C_Item ) { name = NAME_Trank ; mainflag = ITEM_KAT_POTIONS ; flags = ITEM_MULTI ; value = Value_HpEssenz ; visual = \"ItFo_Potion_Health_01.3ds\" ; // <------------ Mesh to use material = MAT_GLAS ; on_state [ 0 ] = UseHealthPotion ; scemeName = \"POTIONFAST\" ; description = \"Essenz heilender Kraft \" ; TEXT [ 1 ] = NAME_Bonus_HP ; COUNT [ 1 ] = HP_Essenz ; TEXT [ 5 ] = NAME_Value ; COUNT [ 5 ] = Value_HpEssenz ; }; In the world-file itself, only the instances name is stored, such as ItFo_Potion_Health_01 in the example above. This requires you to have the Daedalus-VM ready while loading the world, if you want to place all items on that step. Without being able to run instance constructors you're not going to know how the items should look like. Note This is especially unfortunate, since the visual is the only missing piece at load time. You could delay running the script instance constructor until the item is picked up and write a full world importer without ever touching the scripts... If you are dealing with items from the original game only, you may precompute the mapping of script instances to visuals, but that would not work for mods with custom items.","title":"Item"},{"location":"objects/item/#item","text":"Everything you can pick up from the ground is using the Item class. They have the following important properties: Display name Item category (Potion, weapon, ...) Value in Gold/Ore Description Text Then, they all have properties regarding consumables, armor, weapons, and so on, which are just disabled by default. That could be: Script function to run on use, equip and unequip New Visual for the character who equipped this (for armors) Magic cycle and script functions Guild and fake-Guild Spell range For a full list, see this . Depending on the item category, some of these are used while the others are ignored. I imagine this could have been made nicer be creating more classes, and not shoving everything into one base class...","title":"Item"},{"location":"objects/item/#script-dependency-during-world-load","text":"Items can be spawned via script, but usually are loaded straight from the world-file ( .zen ). However, the visual of the item is always defined in the script instance! For example, let's take a look at the Health Potion instance definition (see Mesh to use comment): INSTANCE ItFo_Potion_Health_01 ( C_Item ) { name = NAME_Trank ; mainflag = ITEM_KAT_POTIONS ; flags = ITEM_MULTI ; value = Value_HpEssenz ; visual = \"ItFo_Potion_Health_01.3ds\" ; // <------------ Mesh to use material = MAT_GLAS ; on_state [ 0 ] = UseHealthPotion ; scemeName = \"POTIONFAST\" ; description = \"Essenz heilender Kraft \" ; TEXT [ 1 ] = NAME_Bonus_HP ; COUNT [ 1 ] = HP_Essenz ; TEXT [ 5 ] = NAME_Value ; COUNT [ 5 ] = Value_HpEssenz ; }; In the world-file itself, only the instances name is stored, such as ItFo_Potion_Health_01 in the example above. This requires you to have the Daedalus-VM ready while loading the world, if you want to place all items on that step. Without being able to run instance constructors you're not going to know how the items should look like. Note This is especially unfortunate, since the visual is the only missing piece at load time. You could delay running the script instance constructor until the item is picked up and write a full world importer without ever touching the scripts... If you are dealing with items from the original game only, you may precompute the mapping of script instances to visuals, but that would not work for mods with custom items.","title":"Script Dependency during World Load"},{"location":"objects/mob/","text":"Interactive Object (Mob) As far as I'm aware, nobody knows why objects characters can interact with are called Mobs or Mobsies . I have been told not even actual Piranha Bytes employees know! Anyways, Fig. 1 shows a complete list of all interactive objects in Gothic. Fig. 1: Subclasses of the _Interactive Object class ( Mob )._ Mobs are built upon the same animation state machine system as used by NPCs. Rather than having states named Running Forward and transitions like Standing -> Running Forward , they often use a simpler numbering scheme. Lets look at the Chest in Fig. 2 to give an example. Fig. 2: The two states of a Chest, Closed (a) and Open (b) . For the chest, the following animations are defined: S_S0 (Closed) S_S1 (Open) T_S0_2_S1 (Transition Closed to Open ) T_S1_2_S0 (Transition Open to Closed ) T_S0_TRY (No key, lid is wiggling) This produces the statemachine shown in Fig. 3 . Fig. 3: All possible states a Chest can have. The trick that makes this all work is that the Characters have a similar set of animations! There is one for each state and each transition, for every Mob even! If the Mob goes into a state, the Character follows. Such an animation is shown in Fig. 4 , which is where the Character kicks the chest because it does not open, which causes its lid to wiggle. Fig. 4: Animation named T_CHESTBIG_S0_TRY , matching the wiggling lid of the chest. Note This state-scheme is why in Gothic 1 you have to specifically press the Forward -Button to open Chests or use Mobs in general. Pressing Forward and Backward cycles through the state numbers! It is also possible to branch to different sub-states using the Left and Right keys, but that is rarely used. Gothic 2 automates this process for some Mobs.","title":"Interactive (Mob)"},{"location":"objects/mob/#interactive-object-mob","text":"As far as I'm aware, nobody knows why objects characters can interact with are called Mobs or Mobsies . I have been told not even actual Piranha Bytes employees know! Anyways, Fig. 1 shows a complete list of all interactive objects in Gothic. Fig. 1: Subclasses of the _Interactive Object class ( Mob )._ Mobs are built upon the same animation state machine system as used by NPCs. Rather than having states named Running Forward and transitions like Standing -> Running Forward , they often use a simpler numbering scheme. Lets look at the Chest in Fig. 2 to give an example. Fig. 2: The two states of a Chest, Closed (a) and Open (b) . For the chest, the following animations are defined: S_S0 (Closed) S_S1 (Open) T_S0_2_S1 (Transition Closed to Open ) T_S1_2_S0 (Transition Open to Closed ) T_S0_TRY (No key, lid is wiggling) This produces the statemachine shown in Fig. 3 . Fig. 3: All possible states a Chest can have. The trick that makes this all work is that the Characters have a similar set of animations! There is one for each state and each transition, for every Mob even! If the Mob goes into a state, the Character follows. Such an animation is shown in Fig. 4 , which is where the Character kicks the chest because it does not open, which causes its lid to wiggle. Fig. 4: Animation named T_CHESTBIG_S0_TRY , matching the wiggling lid of the chest. Note This state-scheme is why in Gothic 1 you have to specifically press the Forward -Button to open Chests or use Mobs in general. Pressing Forward and Backward cycles through the state numbers! It is also possible to branch to different sub-states using the Left and Right keys, but that is rarely used. Gothic 2 automates this process for some Mobs.","title":"Interactive Object (Mob)"},{"location":"objects/npc/","text":"NPC The Npc class is used for Humans and Monsters . There is no difference, no subclass, it is all handled using some if-else-magic, visuals and the animation statemachine. Even the Player is an NPC! That makes no sense and that is why in REGoth, for example, I chose to name them Characters . The inner workings of NPCs are a huge topic for itself. But I'm going to give a broad overview: Visual: Whether the Character is a Monster, a Human or an Orc is determined using the Visual, which is always a Skeletal-Mesh. Event-Queue: Most of the times when an NPC is told to do something via scripting, that action is pushed the characters Event-Queue . That queue then contains actions like Walk to some location , Pick up that item , Attach the player , which are all played back in order. The next action is started, when the action in front of the queue is completed. That queue can be interrupted and cleared by certain actions, such as catching fire. AI: While actions are usually executed by the Event-Queue , something needs to fill that queue. This can be done from the games scripts or by the AI, which includes handling fighting and other Npc tasks. Inventory: Each Character has an inventory to store items in. If you played Gothic, you will have noticed that merchants have two different inventories: One for selling stuff and one if you knock them over and want to loot them. Both of these are handled using a single inventory. If a merchant gets knocked out, their shop-inventory gets replaced by their loot-inventory by scripts. There is actually a bug in which that swap was forgotten on the Seekers if they died from an Iceblock spell, which allowed you to loot their spells and armor. Information-Knowledge: Every Character has a Database of which dialog options the player has told to them. From the script, that database can be queried to see whether an Npc has knowledge about something. Daily Routine: If the Event-Queue is empty, the characters daily routine is started. The daily routine specifies where the Npc should be on certain times over the day. An example would be: From 06:00 to _12:00_: Sit at Campfire near the entrance of the Old Camp. From 12:00 to _22:00_: Make swords at the forge. From 22:00 to _06:00_: Sleep in the bed closest to your starting location. The daily routine makes heavy use of Mobs and Spots to get the Npc through the day. Routines usually spawn sub-routines, also known as \"States\", which define the order in which the Npc should use the tools in the forge to make a weapon. Monsters do not have a Daily Routine. They are controlled by a simpler scheduling mechanism: Sleep, Eat, Roam, Repeat. Additionally, they can flee from predators (e.g. Scavengers flee from Snappers if attacked).","title":"Npc"},{"location":"objects/npc/#npc","text":"The Npc class is used for Humans and Monsters . There is no difference, no subclass, it is all handled using some if-else-magic, visuals and the animation statemachine. Even the Player is an NPC! That makes no sense and that is why in REGoth, for example, I chose to name them Characters . The inner workings of NPCs are a huge topic for itself. But I'm going to give a broad overview: Visual: Whether the Character is a Monster, a Human or an Orc is determined using the Visual, which is always a Skeletal-Mesh. Event-Queue: Most of the times when an NPC is told to do something via scripting, that action is pushed the characters Event-Queue . That queue then contains actions like Walk to some location , Pick up that item , Attach the player , which are all played back in order. The next action is started, when the action in front of the queue is completed. That queue can be interrupted and cleared by certain actions, such as catching fire. AI: While actions are usually executed by the Event-Queue , something needs to fill that queue. This can be done from the games scripts or by the AI, which includes handling fighting and other Npc tasks. Inventory: Each Character has an inventory to store items in. If you played Gothic, you will have noticed that merchants have two different inventories: One for selling stuff and one if you knock them over and want to loot them. Both of these are handled using a single inventory. If a merchant gets knocked out, their shop-inventory gets replaced by their loot-inventory by scripts. There is actually a bug in which that swap was forgotten on the Seekers if they died from an Iceblock spell, which allowed you to loot their spells and armor. Information-Knowledge: Every Character has a Database of which dialog options the player has told to them. From the script, that database can be queried to see whether an Npc has knowledge about something. Daily Routine: If the Event-Queue is empty, the characters daily routine is started. The daily routine specifies where the Npc should be on certain times over the day. An example would be: From 06:00 to _12:00_: Sit at Campfire near the entrance of the Old Camp. From 12:00 to _22:00_: Make swords at the forge. From 22:00 to _06:00_: Sleep in the bed closest to your starting location. The daily routine makes heavy use of Mobs and Spots to get the Npc through the day. Routines usually spawn sub-routines, also known as \"States\", which define the order in which the Npc should use the tools in the forge to make a weapon. Monsters do not have a Daily Routine. They are controlled by a simpler scheduling mechanism: Sleep, Eat, Roam, Repeat. Additionally, they can flee from predators (e.g. Scavengers flee from Snappers if attacked).","title":"NPC"},{"location":"objects/objects-overview/","text":"Objects of the World The zEngine heavily relies on Object Oriented Programming : For most of the objects you can see in the game world there is usually one Class representing it. Object specific features are added using inheritance. Fig. 1: Simplified world object class hierarchy of the zEngine. Specialized subclasses are shown in notes. As shown in Fig. 1 , there aren't actually that many different world objects. Here are some observations: Most classes inherit from the generic Object class, even those which are not placed into the world (not shown here). A class needs to inherit from the Vob class (Virtual Object) if its instances are supposed to be placed into the world. The class hierarchy does not make a difference between a Monster or a Human. Even though it is not an NPC, the player's character is also using the Npc class. There are a couple more relevant classes for Visuals and AI, but as those are not actual world objects, these have been omitted from the diagram. Note Actual names of zEngine classes use two different prefixes. For example, there exists a zCVob and an oCVob . The zC -prefix means that this is a non-gothic specific class. All oC -prefixed classes were made specifically for gothic. This is likely because the engine was meant to be used in other games as well, that just never happened. In the following chapters, I'd like to give a quick overview over all the different classes shown in Fig. 1 .","title":"Overview"},{"location":"objects/objects-overview/#objects-of-the-world","text":"The zEngine heavily relies on Object Oriented Programming : For most of the objects you can see in the game world there is usually one Class representing it. Object specific features are added using inheritance. Fig. 1: Simplified world object class hierarchy of the zEngine. Specialized subclasses are shown in notes. As shown in Fig. 1 , there aren't actually that many different world objects. Here are some observations: Most classes inherit from the generic Object class, even those which are not placed into the world (not shown here). A class needs to inherit from the Vob class (Virtual Object) if its instances are supposed to be placed into the world. The class hierarchy does not make a difference between a Monster or a Human. Even though it is not an NPC, the player's character is also using the Npc class. There are a couple more relevant classes for Visuals and AI, but as those are not actual world objects, these have been omitted from the diagram. Note Actual names of zEngine classes use two different prefixes. For example, there exists a zCVob and an oCVob . The zC -prefix means that this is a non-gothic specific class. All oC -prefixed classes were made specifically for gothic. This is likely because the engine was meant to be used in other games as well, that just never happened. In the following chapters, I'd like to give a quick overview over all the different classes shown in Fig. 1 .","title":"Objects of the World"},{"location":"objects/spot/","text":"Freepoint (Spot) Spots (also known as Freepoints) are invisible objects scattered through the world. They are only needed for their location and name and could be compared to a Plain Axes Empty from Blender. Often, Spots are scattered around fireplaces or monster locations. A Spot can then be used by characters or monsters for certain actions. For example, they tell the Npcs where they can sit. If a spot is occupied, the Npc will simply choose the next available spot. If that is also occupied it will usually just stand somewhere, trying to do smalltalk. For Monsters, Spots define where they can go when they want to go for a little walk around they spawning location (Roaming). All of that is realized by giving each Spot a special name, ie. FP_SIT or FP_ROAM . There can be many Spots with the same name, but the game just checks whether the tag is somewhere in the name. The process goes like this: Is there any place where I can sit down at? *Searches for nearby unoccupied FP_SIT spots* Ah, there by the campfire is a nice spot! I'll occupy that for a moment!","title":"Spot"},{"location":"objects/spot/#freepoint-spot","text":"Spots (also known as Freepoints) are invisible objects scattered through the world. They are only needed for their location and name and could be compared to a Plain Axes Empty from Blender. Often, Spots are scattered around fireplaces or monster locations. A Spot can then be used by characters or monsters for certain actions. For example, they tell the Npcs where they can sit. If a spot is occupied, the Npc will simply choose the next available spot. If that is also occupied it will usually just stand somewhere, trying to do smalltalk. For Monsters, Spots define where they can go when they want to go for a little walk around they spawning location (Roaming). All of that is realized by giving each Spot a special name, ie. FP_SIT or FP_ROAM . There can be many Spots with the same name, but the game just checks whether the tag is somewhere in the name. The process goes like this: Is there any place where I can sit down at? *Searches for nearby unoccupied FP_SIT spots* Ah, there by the campfire is a nice spot! I'll occupy that for a moment!","title":"Freepoint (Spot)"},{"location":"objects/vob/","text":"Vob (Virtual Object) Whenever an object goes into the world, it is based on the Vob class. The Vob class adds the following important properties to an object: Transform (Position and Rotation, no Scale) Visual (Mesh, Particle System, Animated Mesh) Frame Updates Physics AI Event-Queue Not all of these features are used on every object. They are only initialized when required. For example, most decorative objects use a Mesh visual and physics for collision, but no AI.","title":"Vob"},{"location":"objects/vob/#vob-virtual-object","text":"Whenever an object goes into the world, it is based on the Vob class. The Vob class adds the following important properties to an object: Transform (Position and Rotation, no Scale) Visual (Mesh, Particle System, Animated Mesh) Frame Updates Physics AI Event-Queue Not all of these features are used on every object. They are only initialized when required. For example, most decorative objects use a Mesh visual and physics for collision, but no AI.","title":"Vob (Virtual Object)"}]}